---
title: Code Complete 读书笔记
welcome: Hello World
---

###### <sub>老司机课程</sub><br />Code Complete 读书笔记<br />──<br /><sup>2021-05-11</sup><br />`#如：文档密级|具体的密级说明#`<br /><br /><br />**pengyu.liu**<br />*Bytepower*

[TOC]





# 第 10 章 使用变量的一般事项

## 数据认知测试

|        名称         |        | 分值 |
| :-----------------: | ------ | :--: |
|    抽象数据类型     |        |  1   |
|        数组         |        |  1   |
|        位图         | Bitmap |      |
|      布尔变量       |        |  1   |
|        B-树         |        | 0.5  |
|      字符变量       |        |  1   |
|       容器类        |        |  1   |
|       双精度        |        | 0.5  |
|  elongated stream   |        |      |
|      枚举类型       |        |      |
|        浮点         |        | 0.5  |
|         堆          |        |      |
|        下标         |        |      |
|        整数         |        |  1   |
|        链表         |        |  1   |
|      具名常量       |        |  1   |
|       文字量        |        |  1   |
|      局部变量       |        |  1   |
|       查找表        |        |      |
|      数据成员       |        |  1   |
|        指针         |        | 0.5  |
|        私用         |        |  1   |
| retoractive synapse |        |      |
|     引用完整性      |        |      |
|         栈          |        |  1   |
|       字符串        |        |  1   |
|      结构变量       |        |  1   |
|         树          |        |  1   |
|       typedef       |        |      |
|       共用体        |        | 0.5  |
|     value chain     |        |      |
|        变体         |        |      |
|                     |        |      |
|                     |        |      |

## 变量定义

- 关闭隐式声明
- 声明全部变量
- ###### 遵循一套命名规则 
  
  - acctNum / acctNo
  - total_value / coin_value / cash_value / cash_num
  - 使用 is, has 前缀
- 检查变量名

## 变量初始化

- 在声明变量时初始化
- 在靠近变量第一次使用的位置初始化它
- ###### 理想情况下，在第一次使用变量的位置声明和定义该变量
- 在可能的情况下使用 final 和 const
- ###### 特别注意计数器和累加器
  
  - i,j,k ...
  - 使用 for range 语法
- ###### 在类的构造函数里初始化该类的数据成员

  - `#Demo:#(theme1)` new / init 一般使用方法

```go
func newPlayer(name string) *Player {
	p := new(Player)
	p.name = name
	return p
}

func (p *Player) init() {
    p.level = 1
    ...
}

func main() {
    p1 := newPlayer("p1")
    
    p2 := new(Player)
    p2.name = "p2"
    p2.init()
}
```



- 检查是否需要重新初始化
- 一次性初始化具名常量；用可执行代码来初始化变量
- 使用编译器设置自动初始化所有变量
- 利用编译器的警告信息
- 检查输入参数的合法性
- 使用内存访问检查工具来检查错误的指针
- 在程序开始时初始化工作内存

## 作用域

- 使变量引用局部化
  - ###### 变量跨度：同一个变量相邻两次被引用中间的行数

```go
var a = 0
var b = 0
var c = 0
a = b + c
// 修改为
var a, b, c = 0, 0, 0
a = b + c
```

- ###### 尽可能缩短变量的存活时间
  
  - 存活时间：一个变量存在期间所跨越的语句总数
  - 全局变量的存活周期和跨度都很长。
- 减小作用域的一般规则
  - 在循环开始之前再去初始化循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量
  - 直到变量即将被使用再为其赋值
  - 把相关语句放到一起
  - ###### 把相关语句提取成子程序
  - ###### 开始时使用最严格的可见性，然后根据需要扩展变量的作用域。

```go
// go 的其他作用域：可以通过 if / for / {} 产生新的作用域。
func foo() {
    a := 1
    b := 2
    {
        a = 10
        b := 20
        println(a, b)
    }
    println(a, b)
}
// 同一级别作用域命名参数可以直接通过 return 返回，不需要接参数，而不是同一级别作用域返回的时候，函数要求返回的参数跟在return后面
func foo2() (res int) {
    res = 1
    {
        res := 10
        return // res is shadowed during return
    }
    return
}
```

## 持续性

> 在数据的生命周期内使用它，可能生命周期结束后数据仍然存在，但是我们不要再使用它。

- 通过调试或断言来检查关键变量的合理取值。
- 使用数据前进行声明和初始化
- 准备抛弃变量时给它们赋予「不合理的数值」
- 编写代码要假设数据没有持续性

## 绑定时间

> 把变量和值绑定在一起的时间
>
> `>(theme1)`  

- ###### 采用越晚的绑定时间越有利，使代码更具有灵活性。

```java
// 硬编码
titleBar.color = 0xFF // 0xFF is hex value for color bule
    
// 编译期绑定
public static final int COLOR_BLUE = 0xFF
public static final int TITLE_BAR_COLOR = COLOR_BLUE

titleBar.color = TITLE_BAR_COLOR

// 运行期绑定
titleBar.color = readTitleBarColor()
```

- ###### 变量与值绑定的时间总结
  - 编码时（使用神秘数值）我们应该避免使用
  - 编译时（具名常量）
  - 加载时（Windos 注册表，Java 属性文件等外部数据源读取数据）
  - 对象实例化时（窗口创建时读取数据）
  - 即时（窗口重绘时读取数据）

## 数据类型和控制结构的关系

- 序列型数据翻译为顺序语句
- 选择型数据翻译为 if / case 语句

```go

```

- 迭代型数据翻译为 for，while 等循环结构

## 为变量指定单一用途

- ###### 避免使用 x, temp 之类无意义的变量，在不同位置多次使用，之间没有关系。
- ###### **避免让代码具有隐含含义** 

```go
// 混合耦合例子 
if pageCount < 0 {
	// err
}

if customerID > 500000 {
    expiredCustomerID = customerID - 500000
}

```

- 确保使用量所有已知声明的变量



# 第 24 章 重构

## 软件演化的类型

## 重构简介

- 重构的定义：在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。refactoring
- 重构的理由
  - ###### 代码重复
  - ###### 冗长的子程序
  - 循环过长或嵌套过深
  - 内聚性太差的类
  - 类的接口未能提供层次一致的抽象
  - ###### 拥有太多参数的参数列表
  - 类的内部修改往往被局限于某个部分
  - ###### 变化导致对多个类的相同修改
  - 对继承体系的同样修改
  - case 语句需要做相同的修改
  - ###### 同时使用的相关数据并未以类的方式进行组织
  - 成员函数使用其他类的特征比使用自身类的特征还要多
  - 过多使用基本数据类型
  - 某个类无所事事
  - 一系列传递流浪数据的子程序
  - 中间人对象无事可做
  - 某个类同其他类关系过于亲密
  - ###### 子程序命名不恰当
  - 数据成员被设置为共用
  - 某个派生类仅使用类基类的很少一部分成员函数
  - 注释被用于解释难懂的代码
  - 使用了全局变量
  - 在子程序调用前使用类设置代码（setup code），或在调用后使用了收尾代码（teardown code）
  - 程序中的一些代码似乎是在将来某个时候才会用到的
- 拒绝重构的理由
  - 作者没写

## 特定的重构

### 「**数据级的重构**」

- ###### 用具名常量代码神秘数值
- ###### 使变量的名字更为清晰且传递更多信息
- ###### 将表达式内联化（减少一次性的中间变量）
- ###### 用函数来代替表达式

```go
tax = employee.salary * taxRate
tax = employee.getTax()
```

- ###### 引入中间变量
- 用多个单一用途变量代替某个多用途变量
- 在局部用途中使用局部变量而不是参数（不要给参数重新赋值使用）
- 将基础数据类型转化为类
- 将一组类型码（type codes）转化为类或枚举类型
- 将一组类型码转化为一个基类及其相应派生类
- 将数组转换为对象
- 把群集（collection）封装起来
- 用数据类来代替传统记录

### 「**语句级的重构**」

- ###### 分解布尔表达式 给布尔表达式表意明确的命名
- ###### 将复杂的布尔表达式转化成命名准确的布尔函数
- ###### 合并条件语句不同部分中的重复代码
- 使用 break 或 return 而不是循环控制变量
- 在嵌套的 if-then-else 语句中一旦知道答案就立即返回，而不是去赋一个返回值。
- ###### 用多态来替代条件语句（尤其是重复的 case 语句）
```go

```
- 创建和使用 null 对象而不是去检测空值

### 「**子程序级的重构**」

- ###### 提取子程序或方法
- ###### 将子程序内联化
- 将冗长的子程序转化为类
- 用简单算法替代复杂算法
- 增加参数
- 删除参数
- ###### 将查询操作从修改操作中独立出来
- ###### 合并相似的子程序，通过参数区分它们的功能
- ###### 将行为取决于参数的子程序拆分开来
- 传递整个对象而非特定成员
- 传递特定成员而非整个对象
- 包装向下转型的操作

### 「**类实现的重构**」

- ###### 将值对象转化为引用对象
- ###### 将引用对象转化为值对象
- 用数据初始化代替虚函数
- 改变成员函数或成员数据的位置
- 将特殊代码提取为派生类
- 将相似代码结合起来放到基类中

### 「类接口的重构」

- 将成员函数放到另一个类中
- 将一个类变成两个
- 删除类
- 去除委托关系
- 去掉中间人
- 用委托代替继承
- 用继承代替委托
- 引入外部的成员函数
- 引入扩展类
- 对暴露在外的成员变量进行封装
- ###### 对于不能修改的类成员，删除相关的 Set() 成员函数
- ###### 隐藏那些不会在类之外被用到的成员函数
- 封装不使用的成员函数
- 合并那些实现非常类似的基类和派生类

### 「系统级的重构」

- 为无法控制的数据创建明确的索引源
- 将单向的类联系改为双向的类联系
- 将双向的类联系改为单向的类联系
- 用 Factory Method 模式而不是简单的构造函数(需要的时机)
- 用异常取代错误处理代码，或者做相反方向的变换

## 安全的重构

- 安全的重构
  - 保存初始代码 git
  - ###### 重构的步伐请小些
  - ###### 同一时间只做一项重构
  - ###### 把要做的事情一条条列出来
  - 设置一个停车场
  - ###### 多使用检查点 commit
  - 利用编译器警告信息
  - ###### 重新测试
  - ###### 增加测试用例
  - 检测对代码的修改

- 不宜重构的情况
  - 不要把重构当作先写后改的代名词
  - 避免用重构代替重写


## 重构策略（时机，重点）

- 在增加子程序是进行重构
- 在添加类的时候进行重构
- 在修补缺陷的时候进行重构
- 关注易于出错的模块
- 关注高度复杂的模块
- 在维护环境下，改善你手中正在处理的代码
- 定义清楚干净代码和拙劣代码的边界，然后尝试把代码移过这条边界



###### The End